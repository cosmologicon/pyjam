# Draw world objects (i.e. in the middle panel)

from __future__ import division
import pygame, math, random, numpy
from . import pview, state, view
from .pview import T

# TODO(Christopher): Even though it's less realistic, I think it might look more dymanic if the
# starfield had a feeling of depth, i.e. not all the stars parallax the same amount when you move.
def randomstar():
	z = random.uniform(0, 10000)
	A = random.uniform(0, 10000)
	return z, A
stardata = [randomstar() for _ in range(10000)]

# TODO: restrict to the central viewing area.
def stars():
	pview.fill((0, 0, 0))
	Nstar = 500  # TODO: change dynamically with resolution
	for z, A in stardata[:Nstar]:
		# TODO: dynamically change with camera zoom level
		pos = T(pview.centerx + 500 * view.dA(A, view.A), 300 * (z - view.zW0) % pview.h)
		# TODO: different colors correlated with depth
		color = 255, 255, 255
		pview.screen.set_at(pos, color)

# Blue sky when close to the ground
def atmosphere():
	alpha = pview.I(math.fadebetween(view.zW0, 10, 255, 100, 0))
	if alpha: 
		pview.fill((100, 130, 220, alpha))



# TODO: when the camera is moving quickly (say, more than 100 pixels per frame), instead of drawing
# a textured cable, just do a solid color (with the shading). This will make it look more smeared
# out.
# Also the stars.

# Drawing the central cable
def buildcabletexture():
	global cabletexture
	w, h = 800, 400
	cabletexture = pygame.Surface((w, h)).convert()
	cabletexture.fill((80, 80, 80))
	for _ in range(100):
		# Stripe slope
		d = random.choice([1, 3, 5])
		n = random.randint(1, d // 2 + 1)
		flip = random.choice([False, True])
		n, d = (1, 3) if flip else (3, 5)
		xstep = pview.I(1 / d * w)
		dx = xstep * n
		# Stripe width
		s = random.randint(5, 10)
		color0 = random.randint(84, 90)
		color = [color0 + random.randint(-1, 1) for _ in range(3)]
		x0 = random.randint(0, w)
		y0, y1 = (0, h) if flip else (h, 0)
		while x0 + dx + s > 0:
			x0 -= xstep
		while x0 < w:
			ps = (x0, y0), (x0 + dx, y1), (x0 + dx + s, y1), (x0 + s, y0)
			pygame.draw.polygon(cabletexture, color, ps)
			x0 += xstep
cabletexture = None  # Will be built on the first call to getcablesurf

# The Surface used to tile the cable at a given zoom level and angle.
# TODO: caching. You don't want to cache every single surface generated by this function, but when
# the camera is stationary, this will be called with the same arguments frame after frame. A good
# compromise is just to cache the most recent call.
def getcablesurf(w, A):
	if cabletexture is None: buildcabletexture()
	w0, h0 = cabletexture.get_size()
	h = pview.I(w * h0 / w0 * math.pi)
	surf = pygame.Surface((w, h)).convert()

	# Range going from -1 to +1
	a = (numpy.arange(w) + 0.5) * 2 / w - 1
	# "Unwrapped" range of the angles covered by each column.
	b = numpy.arcsin(a) / math.tau - A / 8
	# Column within the image.
	xs = (b * w0 + 0.5).astype(int) % w0
	# Fade factor
	fs = 1 - abs(a ** 3)
	# Row within the image
	ys = ((numpy.arange(h) + 0.5) / h * h0 + 0.5).astype(int)

	arr0 = pygame.surfarray.pixels3d(cabletexture)
	arr = pygame.surfarray.pixels3d(surf)
	arr[:,:,:] = (arr0[xs.reshape(w,1), ys.reshape(1,h), :] * fs.reshape(w,1,1)).astype(int)
	return surf

# Main entry point.
def cable():
	w = T(2 * state.radius * view.zoom)
	surf = getcablesurf(w, view.A)
	h = surf.get_height()
	hfull = T(state.top * view.zoom)
	# TODO: make this calculation more stable to small changes in view.zoom.
	xV, yV = view.gametoview((0, 0))
	# TODO: cut off at the top of the tower (or maybe just draw something over it so it looks like
	# the end.
	if yV - pview.h > h:
		yV = (yV - pview.h) % h + pview.h
	while yV > 0:
		rect = surf.get_rect(midbottom = (xV, yV))
		pview.screen.blit(surf, rect)
		yV -= h
	
