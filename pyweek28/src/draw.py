# Draw world objects (i.e. in the middle panel)

from __future__ import division
import pygame, math, random, numpy
from . import pview, state, view
from .pview import T

# TODO(Christopher): Even though it's less realistic, I think it might look more dymanic if the
# starfield had a feeling of depth, i.e. not all the stars parallax the same amount when you move.
def randomstar():
	y = random.uniform(0, 10000)
	A = random.uniform(0, 1)
	return y, A
stardata = [randomstar() for _ in range(10000)]

# TODO: restrict to the central viewing area.
def stars():
	pview.fill((0, 0, 0))
	Nstar = 500  # TODO: change dynamically with resolution
	for y, A in stardata[:Nstar]:
		# TODO: dynamically change with camera zoom level
		pos = T(pview.centerx + 4000 * view.dA(A, view.A), 300 * (y - view.yG0) % pview.h)
		# TODO: different colors correlated with depth
		color = 255, 255, 255
		pview.screen.set_at(pos, color)

def atmosphere():
	# Atmosphere
	alpha = pview.I(math.fadebetween(view.yG0, 10, 255, 100, 0))
	if alpha: 
		pview.fill((100, 130, 220, alpha))



# Drawing the central cable
cabletexture = None
def getcabletexture():
	global cabletexture
	if cabletexture is not None:
		return cabletexture
	w, h = 2048, 1024
	w, h = 800, 400
	cabletexture = pygame.Surface((w, h)).convert()
	cabletexture.fill((80, 80, 80))
	for _ in range(300):
		# Stripe slope
		d = random.choice([1, 3, 5])
		n = random.randint(1, d // 2 + 1)
		flip = random.choice([False, True])
		n, d = (1, 3) if flip else (2, 5)
		xstep = pview.I(1 / d * w)
		dx = xstep * n
		# Stripe width
		s = random.randint(5, 10)
		color0 = random.randint(84, 90)
		color = [color0 + random.randint(-1, 1) for _ in range(3)]
		x0 = random.randint(0, w)
		y0, y1 = (0, h) if flip else (h, 0)
		while x0 + dx + s > 0:
			x0 -= xstep
		while x0 < w:
			ps = (x0, y0), (x0 + dx, y1), (x0 + dx + s, y1), (x0 + s, y0)
			pygame.draw.polygon(cabletexture, color, ps)
			x0 += xstep
	return cabletexture

# The Surface used to tile the cable at a given zoom level and angle.
# TODO: caching. You don't want to cache every single surface generated by this function, but when
# the camera is stationary, this will be called with the same arguments frame after frame. A good
# compromise is just to cache the most recent call.
def getcablesurf(w, A):
	texture = getcabletexture()
	w0, h0 = texture.get_size()
	h = pview.I(w * h0 / w0 * math.pi)
	surf = pygame.Surface((w, h)).convert()

	# Range going from -1 to +1
	a = (numpy.arange(w) + 0.5) * 2 / w - 1
	# "Unwrapped" range of the angles covered by each column.
	b = numpy.arcsin(a) / math.tau - A
	# Column within the image.
	xs = (b * w0 + 0.5).astype(int) % w0
	# Fade factor
	fs = 1 - abs(a ** 3)
	# Row within the image
	ys = ((numpy.arange(h) + 0.5) / h * h0 + 0.5).astype(int)

	arr0 = pygame.surfarray.pixels3d(texture)
	arr = pygame.surfarray.pixels3d(surf)
	arr[:,:,:] = (arr0[xs.reshape(w,1), ys.reshape(1,h), :] * fs.reshape(w,1,1)).astype(int)
	return surf

# Main entry point.
def cable():
	w = T(2 * state.radius * view.zoom)
	surf = getcablesurf(w, view.A)
	h = surf.get_height()
	hfull = T(state.top * view.zoom)
	# TODO: make this calculation more stable to small changes in view.zoom.
	xV, yV = view.gametoview((0, 0))
	# TODO: cut off at the top of the tower (or maybe just draw something over it so it looks like
	# the end.
	if yV - pview.h > h:
		yV = (yV - pview.h) % h + pview.h
	while yV > 0:
		rect = surf.get_rect(midbottom = (xV, yV))
		pview.screen.blit(surf, rect)
		yV -= h
#	pview.screen.blit(cabletexture, (0, 0))



# TODO(Christopher): there are much better looking options than this. Revisit this once we have an
# idea for the art style.

# For now, as a placeholder, stations are represented as a collection of cylinders, and we don't do
# any fancy occlusion, we just draw them in order from the back to the front.
def randomstationpiece():
	xW = random.uniform(-1, 1)
	yW = random.uniform(-1, 1)
	xW, yW = math.norm((xW, yW), 1.2)
	zW = random.uniform(-0.4, 0.4)
	h = random.uniform(0.01, 1) ** 0.5  # Bias toward shorter cylinders
	r = math.clamp(0.5 / h, 0.1, 2)
	color = random.randint(100, 200), random.randint(100, 200), random.randint(100, 200)
	return (xW, yW, zW), h, r, color
stationdata = [randomstationpiece() for _ in range(20)]

# TODO(Christopher): procedurally generate station layouts so they look unique.
def station(yG0, back):
	# TODO: abort early if the entire station is off screen.
	data = [(view.worldtogame(pW), h, w, color) for pW, h, w, color in stationdata]
	# Sort by depth
	data.sort(key = lambda entry: entry[0][1])
	for ((xG, yG), dG), h, r, color in data:
		if (back and dG > 0) or (not back and dG < 0):
			continue
		xV0, yV0 = view.gametoview((xG - r, yG0 + yG + h))
		xV1, yV1 = view.gametoview((xG + r, yG0 + yG - h))
		rect = pygame.Rect(xV0, yV0, xV1 - xV0, yV1 - yV0)
		if pview.rect.colliderect(rect):
			pview.screen.fill(color, rect)
		
	
